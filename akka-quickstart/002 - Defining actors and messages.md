# Описание акторов и сообщений

Кадлый актор описывает тип T сообщений, которые он может принять. Из case-классов и объектов получаются отличные сообщения, так как они иммутабельны по дефолту и имеютт поддержку PM, польза которого при разборе сообщений очевидна.

`Hello World` имеет три типа сообщений:

- Greet - команда отсылается Greeter-у, чтобы вызвать приветствие;
- Gretted - ответ от Greeter-а, подтверждающий получение Greet;
- Start - комманда для GreeterMain, чтобы начать процесс приветствия.

Во время описания акторов и их сообщений следует учитывать положения:

- Сообщения являются единственным публичным API Акторов, поэтому хорошей практикой будет определять сообщения с хорошими именами и богатой симантикой и специфичным для проблемной области значением, даже если они просто являются обёрткой для вашего типа данных. Это сделает их лёгкими в использовании, понятными и доступными для дебага;
- Сообщения должны быть иммутабельны, ведь они ходят между потоками;
- Сообщения, ассоциированные с актором, лучше всего хранить в объекте этого актора. Так будет легче понять, какой тип сообщения актор ожидает и обрабатывает;
- Начальное поведение актора лучше всего описывать в методе `apply` в объекте этого актора.

Посмотрим на исходные коды Quickstart проекта.


## Greeter actor

```scala
object Greeter {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>
    context.log.info("Hello {}!", message.whom)
    //#greeter-send-messages
    message.replyTo ! Greeted(message.whom, context.self)
    //#greeter-send-messages
    Behaviors.same
  }
}
```

- В этом коде определяются два типа сообщений, один для подачи актору команды на приветствие кого-то, а другой для отправки уведомления о том, что приветствие было выполнено.

Принимаемый тип определён в поведении класса: `Behavior[Greet]`. 

- `Greet` содержит не только информацию о том, кому (whom) отправить приветствие, но и `ActorRef`, указывающий, какой актор использовал автор сообщения, чтобы Greeter мог отправить в него сообщение об успехе.

- Поведение актора определено как `Greeter` (в `apply`) посредством фабрики поведений `Behaviors.receive`. Обработка сообщения может закончиться изменением поведения или тем же поведением. Это состояние обновляется путём возвращения нового экземпляра поведения, который будет содержать новое неизменяемое состояние. В примере мы возвращаем экземпляр, который содержит такое же поведение, как текущее: `Behaviors.same`.

- Тип обрабатываемых сообщений для этого поведения определён как класс `Greet`, что означает, что `message` аргумент будет такого типа. Вот почему мы можем автоматически вызывать `message.whom` и `message.replyTo`, не используя PM.

- Ещё мы видим восколицательный знак (оператор `!`). Это оператор `tell`. Актор посылает сообщение другому актору посредством асинхронной операции, не блокирующей поток вызывателя.

- Так как `replyTo` определен типа `ActorRef[Greeted]`, компилятор позволит нам посылать только сообщения этого типа. С другой стороны, сообщение типа `Greeted` может быть написано только актором-обработчиком Greet: `ActorRef[Greet]` (ну, или вложить туда можно только такой актор, в данном случае `context.self`).

- Принимаемые типы сообщений актором и типы его ответов определяют *протокол*, используемый этим актором. В этом случае это простой запрос-ответ протокол, но акторы могут моделировать и по-настоящему сложные протоколы. Протокол вместе с поведением, реализующим его, образует объект `Greeter`.


## Greeter bot actor

```scala
object GreeterBot {

  def apply(max: Int): Behavior[Greeter.Greeted] = {
    bot(0, max)
  }

  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =
    Behaviors.receive { (context, message) =>
      val n = greetingCounter + 1
      context.log.info("Greeting {} for {}", n, message.whom)
      if (n == max) {
        Behaviors.stopped
      } else {
        message.from ! Greeter.Greet(message.whom, context.self)
        bot(n, max)
      }
    }
}
```

- Сразу же видно, что как поведение он принимает тип Greeted. `bot(0,max)` - это не вызов метода. Behavior всегда должен менять поведение в конце (возвращать behavior). Поэтому смотрим внутрь кода `bot`.

- Метод bot прибавляет к полученному числу единицу, выводит сообщение и, если максимум не достигнут, меняет поведение на вызов bot уже с новой цифрой. Получается, изменение переменной достигается путём создания нового поведения, а не хранения переменной. Поэтому не нужны различные механизмы конкурентности вроде `synchronized`.


## Greeter main actor

```scala
object GreeterMain {

  final case class Start(name: String)

  def apply(): Behavior[Start] =
    Behaviors.setup { context =>
      //#create-actors
      val greeter = context.spawn(Greeter(), "greeter")
      //#create-actors

      Behaviors.receiveMessage { message =>
        //#create-actors
        val replyTo = context.spawn(GreeterBot(max = 3), message.name)
        //#create-actors
        greeter ! Greeter.Greet(message.name, replyTo)
        Behaviors.same
      }
    }
}
```

- Этот актор создаёт Greeter и GreeterBot и начинает интеракцию. Создание акторов будет обсуждено в следующем гайде.

