# Описание акторов и сообщений

Кадлый актор описывает тип T сообщений, которые он может принять. Из case-классов и объектов получаются отличные сообщения, так как они иммутабельны по дефолту и имеютт поддержку PM, польза которого при разборе сообщений очевидна.

`Hello World` имеет три типа сообщений:

- Greet - команда отсылается Greeter-у, чтобы вызвать приветствие;
- Gretted - ответ от Greeter-а, подтверждающий получение Greet;
- Start - комманда для GreeterMain, чтобы начать процесс приветствия.

Во время описания акторов и их сообщений следует учитывать положения:

- Сообщения являются единственным публичным API Акторов, поэтому хорошей практикой будет определять сообщения с хорошими именами и богатой симантикой и специфичным для проблемной области значением, даже если они просто являются обёрткой для вашего типа данных. Это сделает их лёгкими в использовании, понятными и доступными для дебага;
- Сообщения должны быть иммутабельны, ведь они ходят между потоками;
- Сообщения, ассоциированные с актором, лучше всего хранить в объекте этого актора. Так будет легче понять, какой тип сообщения актор ожидает и обрабатывает;
- Начальное поведение актора лучше всего описывать в методе `apply` в объекте этого актора.

Посмотрим на исходные коды Quickstart проекта.


## Greeter actor

```scala
object Greeter {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>
    context.log.info("Hello {}!", message.whom)
    //#greeter-send-messages
    message.replyTo ! Greeted(message.whom, context.self)
    //#greeter-send-messages
    Behaviors.same
  }
}
```

- В этом коде определяются два типа сообщений, один для подачи актору команды на приветствие кого-то (Greet, он "принимаемый", так поведение создано так: `Behavior[Greet]`), а другой для отправки уведомления о том, что приветствие было выполнено.

- `Greet` содержит не только информацию о том, кому (whom) отправить приветствие, но и `ActorRef`, указывающий, какой актор использовал автор сообщения, чтобы Greeter мог отправить в него сообщение об успехе.

- Поведение актора определено как `Greeter` (в `apply`) посредством фабрики поведений `Behaviors.receive`. Обработка сообщения может закончиться изменением поведения или тем же поведением. Это состояние обновляется путём возвращения нового экземпляра поведения, который будет содержать новое неизменяемое состояние. В примере мы возвращаем экземпляр, который содержит такое же поведение, как текущее: `Behaviors.same`.

- Тип обрабатываемых сообщений для этого поведения определён как класс `Greet`, что означает, что `message` аргумент будет такого типа. Вот почему мы можем автоматически вызывать `message.whom` и `message.replyTo`, не используя PM.

- Ещё мы видим восколицательный знак (оператор `!`). Это оператор `tell`. Актор посылает сообщение другому актору посредством асинхронной операции, не блокирующей поток вызывателя.

- Так как `replyTo` определен типа `ActorRef[Greeted]`, компилятор позволит нам посылать только сообщения этого типа. С другой стороны, сообщение типа `Greeted` может быть написано только актором-обработчиком Greet: `ActorRef[Greet]` (ну, или вложить туда можно только такой актор, в данном случае `context.self`).

- Принимаемые типы сообщений актором и типы его ответов определяют *протокол*, используемый этим актором. В этом случае это простой запрос-ответ протокол, но акторы могут моделировать и по-настоящему сложные протоколы. Протокол вместе с поведением, реализующим его, образует объект `Greeter`.